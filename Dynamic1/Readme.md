# 동적 계획법(Dynamic Programming)

복잡한 문제를 작은 하위 문제들로 나누어 해결한 후 그 결과를 저장하여 반복 연산을 줄이는 알고리즘 기법

- 특징

  - 중복되는 하위 문제<br/>
    같은 하위 문제가 반복해서 등장
  - 최적 반복 구조<br/>
    문제의 최적해가 그 하위 문제들의 최적해로 구성

- 해결 방법
  - Top-Down + 캐싱<br/>
    큰 문제를 작은 문제로 나누고, 해결된 작은 문제의 결과를 저장(캐싱)하여 재사용
  - Bottom-Up + DP 테이블 사용<br/>
    작은 문제부터 차례대로 해결하면서 결과 저장, 이를 활용하여 큰 문제 해결

<br/>

## 1149번\_RGB거리

- 점화식 <br/>
  $min(dp[N-1][0], dp[N-1][1], dp[N-1][2])$

- 도출 <br/>
  현재 집 기준
  1. `빨강`으로 칠하기 -> 이전 집은 `초록, 파랑` 중 하나로 칠해야 함
     $dp[i][0] = min(dp[i-1][1], dp[i-1][2])$
  2. `초록`으로 칠하기 -> 이전 집은 `빨강, 파랑` 중 하나로 칠해야 함
     $dp[i][1] = min(dp[i-1][0], dp[i-1][2])$
  3. `파랑`a으로 칠하기 -> 이전 집은 `빨강, 초록` 중 하나로 칠해야 함
     $dp[i][2] = min(dp[i-1][0], dp[i-1][1])$

<br/>

## 1904번\_01타일

- 점화식<br/>
  $dp[n]=dp[n-1]+dp[n-2]$

- 도출<br/>
  마지막에 오는 타일 기준

  1. 1로 끝나는 경우
     길이 `n-1`인 경우에 `1`을 추가한 것
  2. 00으로 끝나는 경우
     길이 `n-2`인 경우에 `00`을 추가한 것

- 시간 복잡도<br/>
  `dp[i]`의 값을 O(n)에 계산 가능

<br/>

## 2156번\_포도주 시식

- 점회식<br/>
  $dp[n]=max(dp[n-1], dp[n-3] + wine[n-1]+wine[n], dp[n-2] + wine[n])$

- 도출<br/>
  1. n번째 포도주를 마시지 않는 경우
     $dp[n] = dp[n-1]$
  2. n번째 포도주를 마시는 경우
     - n-1번째 포도주도 마신 경우(n-2번째 포도주는 마시면 안됨)
       $dp[n] = dp[n-3]+wine[n-1]+wine[n]$
     - n-1번째 포도주를 건너뛰고 n번째만 마신 경우
       $dp[n] = dp[n-2] + wine[n]$
